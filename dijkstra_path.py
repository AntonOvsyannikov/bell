import sys

INF = sys.maxsize


def dijkstra_path(g, s, t):
    """Нахождение кратчайшего пути в графе

    Находит кратчайший путь во взвешеном неориентированном графе используя алгоритм Дейкстры

    N - количество вершин
    E - количество ребер

    :param g: Список смежности графа. Каждый узел идентифицируется индексом внутри списка
        Список длины N, элементами являются списки вида [(i,w), ...], где
        i - соседняя вершина, w - вес ребра
    :param s: индекс конечной вершины для поиска пути
    :param t: индекс начальной вершины для поиска пути
    :return: Список индексов вершин, составляющих путь (включая начальную и конечную вершины)
    """

    N = len(g)  # количество вершин

    d = [INF] * N  # вектор расстояний
    m = [False] * N  # вектор меток
    p = [-1] * N  # вектор предков

    d[s] = 0

    for _ in range(N):

        # находим непомеченную вершину с минимальным расстоянием

        v = -1  # индекс вершины с минимальным расстоянием

        for i in range(N):
            if not m[i] and (v == -1 or d[i] < d[v]):
                v = i

        # хотя бы одну непомеченную вершину мы найдем, так как за каждый шаг цикла мы
        # помечаем ровно одну вершину, убедимся в этом
        assert v != -1

        if d[v] == INF: break  # остались только несвязные вершины

        # произведем релаксацию для всех ребер, исходящих из найденной вершины
        for to, w in g[v]:
            if d[v] + w < d[to]:
                d[to] = d[v] + w
                p[to] = v

        # пометим вершину как обработанную
        m[v] = True

    # построим путь
    path = []
    v = t
    while v != s:
        path.append(v)
        v = p[v]
    path.append(s)

    return list(reversed(path))
